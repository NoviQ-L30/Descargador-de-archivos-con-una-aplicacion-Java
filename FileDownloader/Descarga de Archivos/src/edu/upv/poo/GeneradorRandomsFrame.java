package edu.upv.poo;

import java.security.SecureRandom;
import java.util.List;
import javax.swing.JOptionPane;
import javax.swing.SwingWorker;
import java.util.concurrent.*;

/**
 * Clase del JFrame GeneradorRandomsFrame.
 * @author luisroberto
 */
public class GeneradorRandomsFrame extends javax.swing.JFrame {

    /**
     * Executor Service que representa un ThreadPool del tamaño de la cantidad
     * de procesadores lógicos de la computadora. De usa para proceso de CPU 
     * intensos.
     */
    private final ExecutorService executor = Executors.newFixedThreadPool(
            Runtime.getRuntime().availableProcessors());
    
    /**
     * ExecutorService que representa un ThreadPool de tipo cached que no
     * tiene un tamaño fijo, va creciendo conforme a las tareas que van 
     * ingresando. Se usa para procesos cortos, no tan intensos en CPU.
     */
    private final ExecutorService executorCached = 
            Executors.newCachedThreadPool();
    
    /**
     * ExecutorService que representa un ThreadPool de tamaño 1. Se usa para
     * tareas de lectura/escritura a disco.
     */
    private final ExecutorService executorSingle = 
            Executors.newSingleThreadExecutor();
    
    private Future<double[]> generarFuture;
    private ProcesoGenerarRandomsConSwingWorker procesoRandomsSW;
    
    /**
     * Creates new form GeneradorRandomsFrame
     */
    public GeneradorRandomsFrame() {
        initComponents();
        System.out.println(
                    "Ejecución ctor de GeneradorRandomsFrame en Thread " +
                    Thread.currentThread().getName());
    }
    
    /**
     * Obtiene la cantidad de números random a generar, la que se definió en 
     * txtCantidadRandoms.
     * @return La cantidad de randoms a generar ó 0 si no se especificó.
     */
    public final int getCantidadRandoms() {
        try { return Integer.parseInt(txtCantidadRandoms.getText()); }
        catch (NumberFormatException ex) {}
        return 0;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        lblLabelCantidadRandoms = new javax.swing.JLabel();
        txtCantidadRandoms = new javax.swing.JTextField();
        btnGenerarEnMismoHilo = new javax.swing.JButton();
        btnGenerarEnOtroHilo = new javax.swing.JButton();
        btnGenerarConSwingWorker = new javax.swing.JButton();
        btnGenerarConExecutor = new javax.swing.JButton();
        progressBar = new javax.swing.JProgressBar();
        btnGenerarConFuture = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtRandomsGenerados = new javax.swing.JTextArea();
        btnObtenerDeFuture = new javax.swing.JButton();
        btnCancelarFuture = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        lblLabelCantidadRandoms.setText("Cantidad de Randoms a Generar:");

        btnGenerarEnMismoHilo.setText("Generar en Mismo Hilo");
        btnGenerarEnMismoHilo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGenerarEnMismoHiloActionPerformed(evt);
            }
        });

        btnGenerarEnOtroHilo.setText("Generar en Otro Hilo");
        btnGenerarEnOtroHilo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGenerarEnOtroHiloActionPerformed(evt);
            }
        });

        btnGenerarConSwingWorker.setText("Generar con SwingWorker");
        btnGenerarConSwingWorker.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGenerarConSwingWorkerActionPerformed(evt);
            }
        });

        btnGenerarConExecutor.setText("Generar con Executor");
        btnGenerarConExecutor.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGenerarConExecutorActionPerformed(evt);
            }
        });

        progressBar.setStringPainted(true);

        btnGenerarConFuture.setText("Generar con Future");
        btnGenerarConFuture.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGenerarConFutureActionPerformed(evt);
            }
        });

        txtRandomsGenerados.setColumns(20);
        txtRandomsGenerados.setRows(5);
        jScrollPane1.setViewportView(txtRandomsGenerados);

        btnObtenerDeFuture.setText("Obtener de Future");
        btnObtenerDeFuture.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnObtenerDeFutureActionPerformed(evt);
            }
        });

        btnCancelarFuture.setText("Cancelar Future");
        btnCancelarFuture.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCancelarFutureActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(progressBar, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnGenerarEnOtroHilo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnGenerarEnMismoHilo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(lblLabelCantidadRandoms)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(txtCantidadRandoms, javax.swing.GroupLayout.DEFAULT_SIZE, 167, Short.MAX_VALUE))
                    .addComponent(btnGenerarConSwingWorker, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnGenerarConExecutor, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnGenerarConFuture, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnObtenerDeFuture, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnCancelarFuture, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblLabelCantidadRandoms)
                    .addComponent(txtCantidadRandoms, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnGenerarEnMismoHilo)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnGenerarEnOtroHilo)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnGenerarConSwingWorker)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnGenerarConExecutor)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnGenerarConFuture)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnObtenerDeFuture)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnCancelarFuture)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 15, Short.MAX_VALUE)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 224, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnGenerarEnMismoHiloActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGenerarEnMismoHiloActionPerformed
        int cantidad = getCantidadRandoms();
        GenerarRandoms generar = new GenerarRandoms(cantidad);
        generar.run();
        JOptionPane.showMessageDialog(
                this, 
                "Randoms generados, último número: " + 
                        generar.getRandoms()[cantidad - 1], 
                "Generar Randoms", 
                JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_btnGenerarEnMismoHiloActionPerformed

    private void btnGenerarEnOtroHiloActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGenerarEnOtroHiloActionPerformed
        
        // Definición del proceso que va a esperar a que los randoms se generen.
        Runnable procesoEsperar = () -> {
            
            // Definimos el proceso que se va a tardar (el generar los randoms).
            int cantidad = getCantidadRandoms();
            GenerarRandoms proceso = new GenerarRandoms(cantidad);  
            
            // Creamos e iniciamos el hilo donde se generan los randoms.
            Thread threadGenerar = new Thread(proceso);
            threadGenerar.start();
            
            // Aquí esperamos a que el proceso de generar se termine.
            // Para esto usamos el join() que es una operación que bloquea el
            // hilo donde se manda llamar (para este caso será el hilo 
            //threadEsperarGenerar).
            try { threadGenerar.join(); } catch (Exception ex) { }
            
            JOptionPane.showMessageDialog(
                GeneradorRandomsFrame.this, 
                "Randoms generados (en otro Hilo), último número: " + 
                        proceso.getRandoms()[cantidad - 1], 
                "Generar Randoms", 
                JOptionPane.INFORMATION_MESSAGE);
        };
        
        // Creamos e inicializamos el hilo que va a tener toda la ejecución de
        // llamar y esperar el hilo donde se generan los randoms.
        Thread threadEsperaGenerar = new Thread(procesoEsperar);
        threadEsperaGenerar.start();
    }//GEN-LAST:event_btnGenerarEnOtroHiloActionPerformed

    private void btnGenerarConSwingWorkerActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGenerarConSwingWorkerActionPerformed
        
        // Si ya hay un proceso en un SwingWorker ejecutandose, ya no se 
        // realiza la operación de generar otro.
        if (procesoRandomsSW != null) return;
        
        txtRandomsGenerados.setText("");
        
        // Inicializamos el objeto de tipo SwingWorker para la ejecución en
        // segundo plan de la tarea.
        procesoRandomsSW = 
                new ProcesoGenerarRandomsConSwingWorker(getCantidadRandoms());
        
        // Definimos un listener del evento property change para obtener el 
        // cambio de valor del progreso de la operación del SwingWorker.
        procesoRandomsSW.addPropertyChangeListener((e) -> {
            if (e.getPropertyName().equals("progress"))
                progressBar.setValue((int)e.getNewValue());
        });
        
        // Empieza la ejecución del proceso.
        procesoRandomsSW.execute();
    }//GEN-LAST:event_btnGenerarConSwingWorkerActionPerformed

    private void btnGenerarConExecutorActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGenerarConExecutorActionPerformed
        executor.execute(this::generarRandoms);
    }//GEN-LAST:event_btnGenerarConExecutorActionPerformed

    private void btnGenerarConFutureActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGenerarConFutureActionPerformed
        
        // Condición para que cuando tengamos un proceso en ejecución de tipo
        // future, no agregemos otro proceso.
        if (generarFuture != null) {
            JOptionPane.showMessageDialog(
                    this, 
                    "Ya hay otro proceso Future ", 
                    "Generar con Future", JOptionPane.WARNING_MESSAGE);
            return;
        }
        
        // Definición del proceso que a futuro queremos saber su resultado.
        Callable<double[]> generar = () -> {

            // Aquí imprimimos en qué Thread se está ejecutando este proceso.
            System.out.println(
                    "generar en Thread " + Thread.currentThread().getName());

            // Para generar los números random y el array donde los vamos a guardar.
            SecureRandom random = new SecureRandom();
            double[] randoms = new double[getCantidadRandoms()];

            // Ciclo para llenar el array con los randoms generados.
            for (int i = 0; i < randoms.length; i++) {

                // para modificar el progressBar que muestra el progreso de la opeación.
                progressBar.setValue(100 * (i + 1) / randoms.length);

                // Para propósitos de desarrollo, paramos la ejecución por 10ms, 
                // esto para que el proceso no se haga tan rápido...
                try { Thread.sleep(10); } 
                catch (InterruptedException ex) { throw ex; }

                randoms[i] = random.nextDouble();
            }

            // Regresamos los randoms generados. Este array se va a obtener en
            // la función get() del objeto Future obtenido de este operación.
            return randoms;
        };
        
        // Enviamos al executor el proceso, este nos regresará un objeto Future
        // para obtener el resultado de la operación.
        generarFuture = executor.submit(generar);
    }//GEN-LAST:event_btnGenerarConFutureActionPerformed

    private void btnObtenerDeFutureActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnObtenerDeFutureActionPerformed
        
        // Validamos que haya un proces de tipo Future ejecutandose.
        if (generarFuture == null) {
            JOptionPane.showMessageDialog(
                    this, "No hay future ejecutandose", 
                    "Generar con Future", JOptionPane.WARNING_MESSAGE);
            return;
        }
        
        // Si el proceso Future se canceló, terminamos con el Future y 
        // la operación.
        if (generarFuture.isCancelled()) {
            JOptionPane.showMessageDialog(
                    this, "El proceso se canceló, no hay resultados.", 
                    "Generar con Future", JOptionPane.WARNING_MESSAGE);
            generarFuture = null;
            return;
        }
        
        // Validamos que el proceso no siga en ejecución para poder obtener
        // los resultados.
        if (!generarFuture.isDone()) {
            JOptionPane.showMessageDialog(
                    this, "El proceso no ha terminado. Future Ejecutandose.", 
                    "Generar con Future", JOptionPane.INFORMATION_MESSAGE);
            return;
        }
        
        double[] randoms = null;
        try {
            // Aquí obtenemos objetos random generados, los que regresa el
            // objeto Callable.
            randoms = generarFuture.get(100, TimeUnit.MILLISECONDS);
        }
        catch (InterruptedException | ExecutionException ex) {
            JOptionPane.showMessageDialog(
                    this, 
                    String.format(
                            "ERROR (%s): %s", 
                            ex.getClass().getName(), 
                            ex.getMessage()), 
                    "Generar con Future", JOptionPane.ERROR_MESSAGE);
        }
        catch (TimeoutException ex) {
            generarFuture.cancel(true);
            JOptionPane.showMessageDialog(
                    this, 
                    "La operación superó el tiempo de espera permitido", 
                    "Generar con Future", JOptionPane.WARNING_MESSAGE);
        }
            
        generarFuture = null;
        
        if (randoms == null) return;
        
        JOptionPane.showMessageDialog(
                    this, "Randoms obtenidos, ultimo número: " + 
                            randoms[randoms.length - 1], 
                    "Generar con Future", JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_btnObtenerDeFutureActionPerformed

    private void btnCancelarFutureActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCancelarFutureActionPerformed
      
        // Para cancelar también el proceso específicado en un SwingWorker.
        // Si hay un SwingWorker, se cancela.
        if (procesoRandomsSW != null)
            procesoRandomsSW.cancel(true);
        
        // Si no hay un Future en ejecución, se termina la operación.
        if (generarFuture == null) return;
        
        // Se manda cancelar el objeto future. Si este ya fue cancelado o  
        // finalizó antes de cancelarlo, regresará un false la función.
        boolean generarFutureCancelado = generarFuture.cancel(true);
        System.out.println("Cancelaed :" + generarFutureCancelado);        
    }//GEN-LAST:event_btnCancelarFutureActionPerformed

    private void generarRandoms() {
        int cantidad = getCantidadRandoms();
        GenerarRandoms generar = new GenerarRandoms(cantidad);
        generar.run();
        JOptionPane.showMessageDialog(
                    GeneradorRandomsFrame.this, 
                    "Randoms generados. Último número: " + 
                            generar.getRandoms()[cantidad -1], 
                    "Generar con Swing Worker", 
                    JOptionPane.INFORMATION_MESSAGE);
    }
    
    /**
     * @param args the command line arguments
     */
    public static void mainf(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GeneradorRandomsFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GeneradorRandomsFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GeneradorRandomsFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GeneradorRandomsFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GeneradorRandomsFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnCancelarFuture;
    private javax.swing.JButton btnGenerarConExecutor;
    private javax.swing.JButton btnGenerarConFuture;
    private javax.swing.JButton btnGenerarConSwingWorker;
    private javax.swing.JButton btnGenerarEnMismoHilo;
    private javax.swing.JButton btnGenerarEnOtroHilo;
    private javax.swing.JButton btnObtenerDeFuture;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel lblLabelCantidadRandoms;
    private javax.swing.JProgressBar progressBar;
    private javax.swing.JTextField txtCantidadRandoms;
    private javax.swing.JTextArea txtRandomsGenerados;
    // End of variables declaration//GEN-END:variables

    /**
     * Define el proceso de generar randoms en backgroud.
     */
    public class ProcesoGenerarRandomsConSwingWorker
            extends SwingWorker<double[], Double>{

        private final int cantidad;
        private final SecureRandom secureRandom = new SecureRandom();
        
        public ProcesoGenerarRandomsConSwingWorker(int cantidad) {
            this.cantidad = Math.abs(cantidad);
        }
        
        /**
         * Operación que se va a hacer en otro Thread. 
         * @return El resultado de la operación.
         * @throws Exception 
         */
        @Override
        protected double[] doInBackground() throws Exception {
            
            System.out.println(
                    "Ejecución doInBackground en Thread " +
                    Thread.currentThread().getName());
            
            double[] randoms = new double[cantidad];
            for (int i = 0; i < cantidad; i++) {
                if (isCancelled()) return randoms;
                try { Thread.sleep(100); } catch (Exception ex) { }
                randoms[i] = secureRandom.nextDouble();
                setProgress(100 * (i + 1) / cantidad);  // Notificamos del progres.
                publish(randoms[i]);  // publicamos resultados parciales.
            }
            
            return randoms;
        } 
        
        /**
         * Este método va recibiendo los resultados parciales que se envían
         * desde doInBackground con el método publish. Este método se ejecuta
         * en Thread del cual fue llamado el SwingWorker.
         * @param values Los resultados que se han acumulado.
         */
        @Override
        protected void process(List<Double> values) {
            
            System.out.println(
                    "Ejecución SwingWorker.process() en Thread " +
                    Thread.currentThread().getName());
            
            for (double i : values) {
                txtRandomsGenerados.append(Double.toString(i) + "\n");
            }            
        }
        
        /**
         * Se ejecuta cuando termina la operación. Este método se ejecuta aún
         * si la operación falló, se canceló o arrojó una exception. Este 
         * método se ejecuta en el Thread del cual fue llamado el SwingWorker.
         */
        @Override
        protected void done() {
            
            procesoRandomsSW = null;
            
            System.out.println(
                    "Ejecución done() de SW en Thread " +
                    Thread.currentThread().getName());
            
            if (isCancelled()) {
                return;
            }
            
            double[] randoms;
            try {
                randoms = get();
            }
            catch (InterruptedException | ExecutionException ex) {
                JOptionPane.showMessageDialog(
                        GeneradorRandomsFrame.this, 
                        ex.getMessage(), 
                        "Generar con Swing Worker", 
                        JOptionPane.ERROR_MESSAGE);
                return;
            }
            
            JOptionPane.showMessageDialog(
                    GeneradorRandomsFrame.this, 
                    "Randoms generados. Último valor: " + randoms[randoms.length - 1], 
                    "Generar con Swing Worker", 
                    JOptionPane.INFORMATION_MESSAGE);
        }
    }            
}
