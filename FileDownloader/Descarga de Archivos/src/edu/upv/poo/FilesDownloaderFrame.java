package edu.upv.poo;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import javax.swing.table.DefaultTableModel;

/**
 * Representa el JFrame del Files Downloader.
 * @author luisroberto
 */
public class FilesDownloaderFrame extends javax.swing.JFrame {

    /**
     * Estatus que representa que se está iniciando la descarga.
     */
    public static final String ESTATUS_INICIANDO_DESCARGA = "Iniciando Descarga";

    /**
     * Estatus que representa un error en la descarga.
     */
    public static final String ESTATUS_ERROR = "ERROR";

    /**
     * Estatus que representa que la descarga se completó correctamente.
     */
    public static final String ESTATUS_COMPLETADO = "Completado";

    /**
     * Estatus que representa que la descarga se canceló.
     */
    public static final String ESTATUS_CANCELADO = "Cancelado";

    /**
     * Executor service de la operación actual de descargas.
     */
    private ExecutorService executorService;

    /**
     * Indica la cantidad total de descargas en la operación actual.
     */
    private int cantidadDescargas;

    /**
     * Indica la cantidad de descargas completadas, exitosas o con error.
     */
    private int cantidadDescargados;

    /**
     * Creates new form FilesDownloaderFrame
     */
    public FilesDownloaderFrame() {
        initComponents();
        
        // Se inicializa el txtDirectorio con el directorio actual de la app.
        txtDirectorio.setText(Paths.get("").toAbsolutePath().toString());
    }
    
    /**
     * Obtiene la URL a partir del valor ingresado en txtUrl, en caso de que no
     * sea una URL válida, regresa null.
     * @return la URL o null si no es válida.
     */
    public URL getUrl() {
        if (txtUrl.getText() == null || txtUrl.getText().isEmpty()) return null;
        try { return new URL(txtUrl.getText().trim()); } 
        catch (MalformedURLException ex) { }
        return null;
    }

    /**
     * Obtiene el tamaño del ThreadPool a usar, determinado por el valor 
     * ingresado en txtThreadPoolSize.
     * @return El tamaño del ThreadPool, 1 si no es válido.
     */
    public int getThreadPoolSize() {
        int v = 0;
        try { v = Integer.parseInt(txtThreadPoolSize.getText()); }
        catch (NumberFormatException ex) {}
        return v < 1 ? 1 : v;
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        lblLabelDirectorio = new javax.swing.JLabel();
        txtDirectorio = new javax.swing.JTextField();
        lblLabelUrl = new javax.swing.JLabel();
        txtUrl = new javax.swing.JTextField();
        txtNombreArchivo = new javax.swing.JTextField();
        lblLabelNombreArchivo = new javax.swing.JLabel();
        btnAgregarALista = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        tblDescargas = new javax.swing.JTable();
        btnDescargar = new javax.swing.JButton();
        btnBorrar = new javax.swing.JButton();
        btnCancelar = new javax.swing.JButton();
        lblLabelTps = new javax.swing.JLabel();
        txtThreadPoolSize = new javax.swing.JTextField();
        progressBar = new javax.swing.JProgressBar();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        lblLabelDirectorio.setText("Directorio:");

        lblLabelUrl.setText("URL:");

        lblLabelNombreArchivo.setText("Nombre Archivo:");

        btnAgregarALista.setText("Agregar a Lista de Descargas");
        btnAgregarALista.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAgregarAListaActionPerformed(evt);
            }
        });

        tblDescargas.setModel(new TableModelDescargas());
        jScrollPane1.setViewportView(tblDescargas);

        btnDescargar.setText("Descargar");
        btnDescargar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDescargarActionPerformed(evt);
            }
        });

        btnBorrar.setText("Borrar");
        btnBorrar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnBorrarActionPerformed(evt);
            }
        });

        btnCancelar.setText("Cancelar");
        btnCancelar.setEnabled(false);
        btnCancelar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCancelarActionPerformed(evt);
            }
        });

        lblLabelTps.setText("TPS:");

        txtThreadPoolSize.setText("2");

        progressBar.setStringPainted(true);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(progressBar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblLabelDirectorio)
                            .addComponent(lblLabelUrl)
                            .addComponent(lblLabelNombreArchivo))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(txtDirectorio)
                            .addComponent(txtUrl)
                            .addComponent(txtNombreArchivo)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(btnAgregarALista, javax.swing.GroupLayout.PREFERRED_SIZE, 450, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnBorrar, javax.swing.GroupLayout.DEFAULT_SIZE, 211, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(lblLabelTps)
                        .addGap(3, 3, 3)
                        .addComponent(txtThreadPoolSize, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnDescargar, javax.swing.GroupLayout.PREFERRED_SIZE, 345, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnCancelar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblLabelDirectorio)
                    .addComponent(txtDirectorio, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblLabelUrl)
                    .addComponent(txtUrl, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txtNombreArchivo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lblLabelNombreArchivo))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnAgregarALista)
                    .addComponent(btnBorrar))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 494, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(progressBar, javax.swing.GroupLayout.DEFAULT_SIZE, 33, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnDescargar)
                    .addComponent(btnCancelar)
                    .addComponent(lblLabelTps)
                    .addComponent(txtThreadPoolSize, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Event handler del botón btnDescargar.
     * @param evt Event argument.
     */
    private void btnDescargarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDescargarActionPerformed
        
        // De habilitan y deshabilitan controles.
        btnDescargar.setEnabled(false);
        btnCancelar.setEnabled(true);
        btnAgregarALista.setEnabled(false);
        btnBorrar.setEnabled(false);
        progressBar.setValue(0);

        // Creación del executor service para la operación de descarga de archivos.
        executorService = Executors.newFixedThreadPool(getThreadPoolSize());

        // Del TableModel de tblDescargas, obtenemos las descargas a realizar.
        TableModelDescargas tModel = (TableModelDescargas)tblDescargas.getModel();
        ADescargar[] aDescargar = tModel.getDescargas();

        // Estabecimiento de los valores iniciales de los contadores.
        cantidadDescargas = aDescargar.length;
        cantidadDescargados = 0;

        // Por cada elemento a descargar, se crea el proceso Runnable y se envía al ExecutorService
        // para la operación actual.
        for (ADescargar i : aDescargar) {
            executorService.execute(new DescargarProceso(i));
        }
        
        // Creamos otro thread para monitorear cuando se completen todas las descargas 
        // del proceso actual.
        Thread threadEsperarTerminarDescargas = new Thread(() -> {

            // Esto para que el ExecutorService no pueda recibir más operaciones.
            executorService.shutdown();  
            try {
                // Esta operación espera que se termine todos los procesos del 
                // ExecutorService. Esta operación bloquea el thread en el que se ejecuta,
                // pero como lo tenemos en otro thread, no bloquea la GUI.
                executorService.awaitTermination(1000, TimeUnit.DAYS);
            } 
            catch (InterruptedException e) {}

            executorService = null;  // Ya no ocupamos el ExecutorService actual.
            btnCancelar.setEnabled(false);
            btnAgregarALista.setEnabled(true);
            btnDescargar.setEnabled(true);
            btnBorrar.setEnabled(true);
        });
        threadEsperarTerminarDescargas.start();  // Mandamos ejecutar el thread.
    }//GEN-LAST:event_btnDescargarActionPerformed

    /**
     * Event handler del botón btnAgregarALista.
     * @param evt Event argument.
     */
    private void btnAgregarAListaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAgregarAListaActionPerformed
        
        // Obtenemos el TableModel y en este agregamos la nueva descarga.
        TableModelDescargas tModel = (TableModelDescargas)tblDescargas.getModel();
        tModel.agregarDescarga(txtUrl.getText(), txtNombreArchivo.getText());
        
        // Reset de los controles para agregar una nueva descarga.
        txtUrl.setText("");
        txtNombreArchivo.setText("");
        txtUrl.requestFocus();
    }//GEN-LAST:event_btnAgregarAListaActionPerformed

    /**
     * Event handler del botón btnCancelar.
     * @param evt Event argument.
     */
    private void btnCancelarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCancelarActionPerformed
        
        // Reset de los controles.
        btnAgregarALista.setEnabled(true);
        btnDescargar.setEnabled(true);
        btnCancelar.setEnabled(false);
        btnBorrar.setEnabled(true);

        // Mandamos terminar la ejecución (todos los procesos pendientes) del ExecutorService,
        // este regresa una lista de objetos Runnable de las operaciones que no se pudieron 
        // ejecutar, la cual nos va a servir para identificar cuales fueron las descargas que
        // no se realizaron.
        List<Runnable> descargasNoEmpezadas = executorService.shutdownNow();

        TableModelDescargas tModel = (TableModelDescargas)tblDescargas.getModel();
        for (Runnable r : descargasNoEmpezadas) {

            // El Runnable es un objeto de tipo DescargarProceso, por el cual podemos obtener
            // la información de la ejecución que no se realizó.
            DescargarProceso descargarProceso = (DescargarProceso)r;

            // Cambiamos el estatus a Cancelado para esta descarga.
            tModel.cambiarEstatus(descargarProceso.aDescargar, ESTATUS_CANCELADO);
        }
    }//GEN-LAST:event_btnCancelarActionPerformed

    /**
     * Event handler del botón btnBorrar.
     * @param evt Event argument.
     */
    private void btnBorrarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnBorrarActionPerformed
        TableModelDescargas tModel = (TableModelDescargas)tblDescargas.getModel();
        tModel.borrarSeleccionado();
    }//GEN-LAST:event_btnBorrarActionPerformed

    /**
     * Realiza el cambio de estatus de una descarga. Este método es synchronized para que solo
     * un Thread a la vez pueda realizar este proceso; esto nos asegura que no tendremos datos
     * inconsistentes en el objeto FilesDownloaderFrame.
     * @param aDescargar Objeto que representa la descarga a cambiar el estatus.
     * @param estatus El estatus al que queremos cambiar la descarga.
     */
    private synchronized void cambiarEstatusDescarga(ADescargar aDescargar, String estatus) {
        
        // Obtenemos el TableModel de tblDescargas, y con este cambiamos el estatus.
        TableModelDescargas tModel = (TableModelDescargas)tblDescargas.getModel();
        tModel.cambiarEstatus(aDescargar, estatus);

        // Si se completo la descarga (con error o exito) modificamos el progreso de la operación.
        if (estatus.equals(ESTATUS_ERROR) || estatus.equals(ESTATUS_COMPLETADO)) {
            cantidadDescargados++;
            progressBar.setValue(cantidadDescargados * 100 / cantidadDescargas);
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(FilesDownloaderFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(FilesDownloaderFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(FilesDownloaderFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(FilesDownloaderFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> new FilesDownloaderFrame().setVisible(true));
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnAgregarALista;
    private javax.swing.JButton btnBorrar;
    private javax.swing.JButton btnCancelar;
    private javax.swing.JButton btnDescargar;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel lblLabelDirectorio;
    private javax.swing.JLabel lblLabelNombreArchivo;
    private javax.swing.JLabel lblLabelTps;
    private javax.swing.JLabel lblLabelUrl;
    private javax.swing.JProgressBar progressBar;
    private javax.swing.JTable tblDescargas;
    private javax.swing.JTextField txtDirectorio;
    private javax.swing.JTextField txtNombreArchivo;
    private javax.swing.JTextField txtThreadPoolSize;
    private javax.swing.JTextField txtUrl;
    // End of variables declaration//GEN-END:variables

    /**
     * Representa el TableModel de tblDescargas, el cual contiene la funcionalidad para interactuar
     * con los datos de la tabla.
     */
    class TableModelDescargas extends DefaultTableModel {
        
        /**
         * Objetos ADescargar de los elementos que queremos descargar.
         */
        private final ArrayList<ADescargar> descargas = new ArrayList<>();
        
        /**
         * Contiene los tipos de datos de las columnas.
         */
        private final Class[] types = new Class [] {
            java.lang.String.class, java.lang.String.class, java.lang.String.class
        };

        /**
         * Inicializa una nueva instancia de TableModelDescargas.
         */
        public TableModelDescargas() {
            // Mandamos llamar la super clase con los parámetros de los registros iniciales
            // y con los nombres de las columnas de la tabla.
            super(
                    new Object [][] { }, 
                    new String [] { "URL", "Nombre Archivo", "Estatus"});
        }
        
        @Override
        public Class getColumnClass(int columnIndex) {
            return types[columnIndex];
        }
        
        /**
         * Agrega un nuevo elemento de descarga a la tabla.
         * @param urlStr La URL del recurso que se quiere descargar.
         * @param nombreArchivo El nombre del archivo que se quiere guardar.
         */
        public void agregarDescarga(String urlStr, String nombreArchivo) {

            // Se obtiene el objeto URL y si es null, no agregamos el registro.
            URL url = getUrlSafe(urlStr);
            if (url == null || nombreArchivo == null || nombreArchivo.isEmpty())
                return;

            // Agregamos el row a la tabla, como un array de objects con los valores
            // que queremos mostrar en la tabla.
            Object[] row = new Object[] { urlStr, nombreArchivo, "" };
            insertRow(descargas.size(), row);

            // Creamos un objeto ADescargar que representa la descarga.
            descargas.add(new ADescargar(nombreArchivo, url, txtDirectorio.getText()));            
        }
        
        /**
         * Realiza la operación de borrar un elemento de la tabla, quita un registro
         * de ADescargar.
         */
        public void borrarSeleccionado() {
            int ix = tblDescargas.getSelectedRow();
            if (ix < 0) return;
            removeRow(ix);
            descargas.remove(ix);
        }
        
        /**
         * Obtenemos un array de objetos ADescargar que representa los elementos
         * que queremos descargar.
         * @return Array de ADescargar.
         */
        public ADescargar[] getDescargas() {
            return descargas.toArray(new ADescargar[] {});
        }

        /**
         * Cambia el estatus en la tabla de un registro específico de descarga.
         * @param aDescargar Objeto que representa el elemento a descargar del cual queremos
         * cambiar el estatus.
         * @param estatus Texto del estatus al que queremos cambiar la descarga en la tabla.
         */
        public void cambiarEstatus(ADescargar aDescargar, String estatus) {
            if (aDescargar == null) return;

            // Del ArrayList obtenemos el index de elemento a descargar.
            int ix = descargas.indexOf(aDescargar);

            // Modificamos el valor en la tabla.
            if (ix != -1) setValueAt(estatus, ix, 2);
        }
        
        /**
         * Obtiene un objeto URL.
         * @param urlStr La URL en string.
         * @return Objeto URL, null si no es válido.
         */
        private URL getUrlSafe(String urlStr) {
            if (urlStr == null || urlStr.isEmpty()) return null;
            try { return new URL(urlStr); } catch (MalformedURLException ex) {}
            return null;
        }
    }
    
    /**
     * Representa un elemento a descargar.
     */
    public class ADescargar {
        
        private final String nombreArchivo;
        private final URL url;
        private final String directorio;
        private final Path path;
        
        /**
         * Inicializa una nueva instancia de ADescargar.
         * @param nombreArchivo Nombre del archivo con el que se quiere guardar en disco.
         * @param url URL de donde se desea descargar.
         * @param directorio Directorio donde se desea guardar la descarga.
         */
        public ADescargar(String nombreArchivo, URL url, String directorio) {
            this.directorio = directorio;
            this.url = url;
            this.nombreArchivo = nombreArchivo;
            path = Paths.get(directorio, nombreArchivo);  // Obtención del Path.
        }

        /**
         * Obtiene el nombre del archivo a guardar en disco.
         * @return El nombre del archivo a guardar en disco.
         */
        public final String getNombreArchivo() { return nombreArchivo; }

        /**
         * La URL del recurso de donde se va a descargar.
         * @return La URL
         */
        public final URL getUrl() { return url; }

        /**
         * Obtiene el directorio del disco donde se desea guardar el archivo.
         * @return El directorio.
         */
        public final String getDirectorio() { return directorio; }        
        
        /**
         * Obtiene el Path que representa la ubicación del archivo en el disco.
         * @return El Path del archivo en disco.
         */
        public Path getPath() { return path; }
    }

    /**
     * Representa el proceso de descargar el archivo desde una URL.
     */
    public class DescargarProceso implements Runnable {

        /**
         * Objeto que representa el archivo a descargar.
         */
        private final ADescargar aDescargar;

        /**
         * Inicializa una nueva instancia de DescargarProceso.
         * @param aDescargar El elemento a descargar.
         */
        public DescargarProceso(ADescargar aDescargar) {
            this.aDescargar = aDescargar;
        }

        /**
         * Obtiene el objeto que representa el archivo a descargar.
         * @return El elemento a descargar.
         */
        public final ADescargar getADescargar() { return aDescargar; }

        @Override
        public void run() {

            // Esto es para que cuando se cancele la operación, ya no se ejecute.
            // Esto porque al cancelarse, el método sleep arroja un InterruptedException. 
            try { Thread.sleep(1); } 
            catch (InterruptedException ex) { return; }

            // Notificamos que se inicia con la descarga.
            cambiarEstatusDescarga(aDescargar, ESTATUS_INICIANDO_DESCARGA);

            try {

                // Se abre la conexión al recurso.
                URLConnection urlConnection = aDescargar.getUrl().openConnection();

                // Se obtiene el tamaño del recuro que se quiere descargar, esto para calcular
                // el porcenaje de descarga.
                long tamaño = urlConnection.getContentLengthLong();

                // Obtenemos un stream del cual se obtiene el recurso byte por byte, que
                // posteriormente lo vamos a guardar en disco.
                try (InputStream stream = urlConnection.getInputStream()) {
                    guardarEnDisco(stream, tamaño);
                }   // Aquí se libera el recuros de la conexión.
            }
            catch (IOException ex) {  // Algun error de IO.

                // Se notifica que en la descarga se presentó un error.
                cambiarEstatusDescarga(aDescargar, ESTATUS_ERROR);
                return;  // fin de la operación (si error).
            }

            // Se notifica que se completó la descarga.
            cambiarEstatusDescarga(aDescargar, ESTATUS_COMPLETADO);  
        }

        /**
         * Guarda en disco un archivo a partir de un Stream que va a leer byte por byte.
         * @param stream Stream que queremos guardar a disco.
         * @param tamaño Tamaño del archivo.
         * @throws IOException
         */
        private void guardarEnDisco(InputStream stream, long tamaño) throws IOException {

            // Creamos un objeto FileOutputStream que nos permite escribir el archivo
            // en el disco en cierta ubicación.
            try (FileOutputStream fileStream = new FileOutputStream(aDescargar.getPath().toFile())) {

                int b, progreso = 0,  ultimoProgreso = 0;
                long bytesLeidos = 0;
                
                // Ciclo que va a leer byte por byte el stream de la conexión al recurso
                // (el especificado en la URL).
                while ((b = stream.read()) != -1) {

                    fileStream.write(b);  // Se escribe el byte leido al archivo.
                    bytesLeidos++;  // Para saber que ya leimos otro byte y llevar la cuenta.
                    ultimoProgreso = progreso;  // El último progreso calculado.
                    
                    // Calculo del progreso en función de los bytes leidos y del tamaño total.
                    progreso = (int)(bytesLeidos * 100L / tamaño);

                    // Si el progreso es diferente, se notifica el cambio de progreso.
                    if (ultimoProgreso != progreso)
                        cambiarEstatusDescarga(aDescargar, Integer.toString(progreso) + "%");
                }
            }  // aquí se cierra el stream para liberar los recursos.
        }
    }
}
